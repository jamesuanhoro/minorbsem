# Helper functions in package

#' Package on attach message
#' @returns R version minimum as string
#' @keywords internal
.onAttach <- function(libname, pkgname) {
  version <- minorbsem_version()
  packageStartupMessage(" ")
  packageStartupMessage(strrep("#", 79))
  packageStartupMessage("This is ", paste(pkgname, version))
  packageStartupMessage(
    "\nAll users of R (or SEM) are invited to report bugs, ",
    "submit functions or ideas\nfor functions. ",
    "An efficient way to do this is to open an issue on GitHub\n",
    "https://github.com/jamesuanhoro/minorbsem/issues/."
  )
  packageStartupMessage(strrep("#", 79))
}

#' Get package version function
#' @returns Package version as string
#' @keywords internal
minorbsem_version <- function() {
  version <- read.dcf(
    system.file("DESCRIPTION", package = "minorbsem"),
    fields = "Version"
  )[1]
  return(version)
}

#' Get R minimum function
#' @returns R version minimum as string
#' @keywords internal
minimum_r_version <- function() {
  r_version_info <- read.dcf(
    system.file("DESCRIPTION", package = "minorbsem"),
    fields = "Depends"
  )[1]
  r_version <- trimws(gsub("R \\(>=|\\)", "", r_version_info))
  return(r_version)
}

#' Run generic CFA and SEM function
#' @returns NULL
#' @export
init_minorbsem <- function() {
  model_syntax <- "
  F1 =~ x1 + x2 + x3\n F2 =~ x4 + x5 + x6\n F3 =~ x7 + x8 + x9"
  minorbsem(
    model_syntax, minorbsem::HS,
    warmup = 200, sampling = 200, chains = 1, show = FALSE,
    method = "none", refresh = 0, show_messages = FALSE
  )
  model_syntax <- "
  ind60 =~ x1 + x2 + x3\n dem60 =~ y1 + y2 + y3 + y4
    dem65 =~ y5 + y6 + y7 + y8\n dem60 ~ ind60\n dem65 ~ ind60 + dem60"
  minorbsem(
    model_syntax, minorbsem::PD,
    warmup = 200, sampling = 200, chains = 1, show = FALSE,
    method = "none", refresh = 0, show_messages = FALSE
  )
  return(NULL)
}

#' Check user input function
#' @description A function that checks user input for adequacy
#' and fails on inadequate input.
#' @param type string for type of check
#' @param object_1 Object to check
#' @param object_2 Object to check
#' @param object_3 Object to check
#' @param object_4 Object to check
#' @returns NULL
#' @keywords internal
user_input_check <- function(
    type,
    object_1 = NULL,
    object_2 = NULL,
    object_3 = NULL,
    object_4 = NULL) {
  if (type == "model" && is.null(object_1)) {
    stop("Model cannot be null")
  }

  if (type == "priors") {
    if (!inherits(object_1, "mbsempriors")) {
      stop("See ?new_mbsempriors for how to set up priors.")
    }
  }

  if (grepl("method", type)) {
    accepted_methods <- method_hash()
    if (!tolower(object_1) %in% tolower(accepted_methods)) {
      err_msg <- paste0(
        "method must be one of the following: ",
        paste0("\"", accepted_methods, "\"", collapse = ", ")
      )
      stop(err_msg)
    }
  }

  if (type == "data") {
    if (is.null(object_1) && (is.null(object_2) || is.null(object_3))) {
      stop(paste0(
        "User must provide either:\n\t",
        "(i) a dataset or\n\t",
        "(ii) sample covariance and sample size"
      ))
    }
  }

  if (type == "target") {
    err_msg <- paste0(
      "type must be either: \"rstan\" or \"cmdstan\""
    )
    if (is.null(object_1)) stop(err_msg)
    if (!object_1 %in% c("rstan", "cmdstan")) stop(err_msg)
    if (object_1 == "cmdstan") {
      # CmdStan path must be set
      tryCatch(cmdstanr::cmdstan_path(),
        error = function(e) {
          stop(paste0(
            "Error: CmdStan path has not been set yet.", " ",
            "See ?cmdstanr::set_cmdstan_path()."
          ))
        }
      )
    }
  }

  return(NULL)
}

#' target fitter function
#' @description A function that takes user input and fits the
#' Stan model.
#' @param data_list Data list object passed to Stan
#' @inheritParams minorbsem
#' @returns Fitted Stan model
#' @keywords internal
target_fitter <- function(
    target,
    data_list,
    seed,
    warmup,
    sampling,
    refresh,
    adapt_delta,
    max_treedepth,
    chains,
    ncores,
    show_messages) {
  init_resid <- "random"
  if (data_list$method < 90 || target == "cmdstan") {
    init_resid <- function() {
      list(
        resids = rep(1e-3, (data_list$Ni^2 - data_list$Ni) / 2)
      )
    }
  }

  if (target == "rstan") {
    if (data_list$sem_indicator == 0) {
      mod_resid <- stanmodels$cfa_resid_rs
    } else if (data_list$sem_indicator == 1) {
      mod_resid <- stanmodels$sem_resid_rs
    }

    suppressWarnings(stan_fit <- rstan::sampling(
      mod_resid,
      data = data_list,
      chains = chains,
      cores = ncores,
      seed = seed,
      warmup = warmup,
      iter = warmup + sampling,
      refresh = refresh,
      init = init_resid,
      control = list(
        adapt_delta = adapt_delta,
        max_treedepth = max_treedepth
      ),
      show_messages = show_messages
    ))
    message(rstan::check_hmc_diagnostics(stan_fit))
  } else if (target == "cmdstan") {
    message(paste0(
      "Compiling Stan code ...\n",
      "This takes a while the first time you run a CFA ",
      "and the first time you run an SEM"
    ))

    if (data_list$sem_indicator == 0) {
      mod_resid <- cmdstanr::cmdstan_model(
        system.file("cmdstan/cfa_resid.stan", package = "minorbsem"),
        stanc_options = list("O1")
      )
    } else if (data_list$sem_indicator == 1) {
      mod_resid <- cmdstanr::cmdstan_model(
        system.file("cmdstan/sem_resid.stan", package = "minorbsem"),
        stanc_options = list("O1")
      )
    }

    message("Fitting Stan model ...")

    stan_fit <- mod_resid$sample(
      data = data_list,
      seed = seed,
      iter_warmup = warmup,
      iter_sampling = sampling,
      refresh = refresh,
      init = init_resid,
      adapt_delta = adapt_delta,
      max_treedepth = max_treedepth,
      chains = chains,
      parallel_chains = ncores,
      show_messages = show_messages
    )
  }

  return(stan_fit)
}

#' Select random method and random case function
#'
#' @returns randomly selected method and case
#' @keywords internal
random_method_selection <- function() {
  accepted_methods <- method_hash()

  method <- sample(accepted_methods, 1)

  case_fun <- sample(1:2, 1)
  if (case_fun == 1) {
    method <- tolower(method)
  } else if (case_fun == 2) {
    method <- toupper(method)
  }

  print(method)
  return(method)
}

#' converter function
#' @description A function that swaps type from string to integer
#' and vice-versa
#' @param search_term Integer or string or NULL
#' @param str_list Character vector of accepted values
#' @returns If search_term is integer, returns string and vice-versa
#' @keywords internal
converter_helper <- function(search_term, str_list) {
  if (is.null(search_term)) {
    converted_value <- names(str_list)
  } else if (is.integer(search_term) || is.numeric(search_term)) {
    search_term <- as.integer(search_term)
    converted_value <- names(str_list)[which(search_term == str_list)]
  } else if (is.character(search_term)) {
    idx <- which(tolower(search_term) == tolower(names(str_list)))
    converted_value <- as.integer(str_list[idx])
  }

  return(converted_value)
}

#' Method hash function
#' @description A function that swaps method from string to integer
#' and vice-versa
#' @inheritParams converter_helper
#' @returns If search_term is integer, returns string and vice-versa
#' @keywords internal
method_hash <- function(search_term = NULL) {
  # Reserving 90+ for methods with no residuals
  list_methods <- c(
    "normal" = 1,
    "lasso" = 2,
    "logistic" = 3,
    "GDP" = 4,
    "WB" = 90,
    "WB-cond" = 91,
    "WW" = 92,
    "none" = 100
  )
  converted_value <- converter_helper(search_term, list_methods)
  return(converted_value)
}

#' Multivariate normal density function
#'
#' @param x_mat the data matrix
#' @param mu mean vector
#' @param s_mat covariance matrix
#' @returns sum of casewise log-likelihood
#' @keywords internal
mb_ldmvn <- function(x_mat, mu, s_mat) {
  k <- nrow(x_mat)
  rooti <- backsolve(chol(s_mat), diag(k))
  quads <- colSums((crossprod(rooti, x_mat - mu))^2)
  return(-(k / 2) * log(2 * pi) + sum(log(diag(rooti))) - .5 * quads)
}

#' Posterior summary helper function
#' @description A function that slightly modifies the default
#' summary function in posterior package
#' @param stan_fit Fitted Stan object
#' @param variable Variable(s) to search for in Stan
#' @param interval Confidence interval to select
#' @param major If TRUE, add some preamble for printing the major
#' parameters table.
#' @returns Summary of posterior draws
#' @keywords internal
mbsem_post_sum <- function(stan_fit, variable, interval = .9, major = FALSE) {
  draws <- posterior::subset_draws(
    posterior::as_draws(stan_fit),
    variable = variable
  )

  lo_lim <- (1.0 - interval) / 2.0
  up_lim <- 1.0 - lo_lim # nolint
  sum_stats <- posterior::summarise_draws(
    draws, "mean", "median", "sd", "mad",
    ~ quantile(.x, probs = c(lo_lim, up_lim), na.rm = TRUE)
  )
  convergence_metrics <- posterior::summarise_draws(
    draws, posterior::default_convergence_measures()
  )

  result <- as.data.frame(merge(
    sum_stats, convergence_metrics,
    by = "variable"
  ))

  var_order <- sum_stats$variable
  # Without this, the row order within param type changes after merging
  result <- result[match(var_order, result$variable), ]

  if (isTRUE(major)) {
    result <- cbind(
      variable = result$variable,
      group = "", from = "", op = "", to = "",
      result[, -1]
    )
  }

  return(result)
}

#' Modify major parameters table helper function
#' @description A function that adds user friendly descriptions to the
#' major parameters table
#' @param major_parameters Major paramters table
#' @param idxs Relevant rows indexes
#' @param group Parameter group
#' @param op lavaan style operator
#' @param from Variable from
#' @param to Variable to
#' @returns Updated major parameters table
#' @keywords internal
modify_major_params <- function(
    major_parameters,
    idxs,
    group = "",
    op = "",
    from = "",
    to = "") {
  result <- major_parameters

  if (length(idxs) > 0) {
    result[idxs, ]$group <- group
    result[idxs, ]$op <- op
    result[idxs, ]$from <- from
    result[idxs, ]$to <- to
  }

  return(result)
}

#' Create major parameters helper function
#' @description A function that creates the table of major parameters
#' @param stan_fit Fitted Stan object
#' @param data_list Data list object passed to Stan
#' @param interval Confidence interval to select
#' @returns Summary of posterior draws
#' @keywords internal
create_major_params <- function(stan_fit, data_list, interval = .9) {
  indicator_labels <- rownames(data_list$loading_pattern)
  factor_labels <- colnames(data_list$loading_pattern)

  params <- c("ppp", "rms_src")
  from_list <- c("PPP", "RMSE")

  load_idxs <- paste0("Load_mat[", apply(which(
    data_list$loading_pattern >= ifelse(data_list$complex_struc == 1, -999, 1),
    arr.ind = TRUE
  ), 1, paste0, collapse = ","), "]")
  params <- c(params, load_idxs)

  if (data_list$Nce > 0) {
    params <- c(params, "res_cor")
  }

  if (data_list$sem_indicator == 0) {
    params <- c(params, "res_var")

    params <- c(params, "phi_mat")
  } else if (data_list$sem_indicator == 1) {
    # Get interfactor correlations
    if (data_list$Nf_corr > 0) {
      params <- c(params, "phi_cor")
    }

    # Get R-square
    params <- c(params, "r_square")

    # Get factor coefficients
    coef_idxs <- paste0("Coef_mat[", apply(which(
      data_list$coef_pattern == 1,
      arr.ind = TRUE
    ), 1, paste0, collapse = ","), "]")
    params <- c(params, coef_idxs)
  }

  major_parameters <- mbsem_post_sum(
    stan_fit = stan_fit, variable = params, interval = interval, major = TRUE
  )

  # Dump duplicates CFA inter-factor correlations here
  duplicates <- duplicated(
    major_parameters[, c("mean", "median", "sd", "mad", "rhat", "ess_bulk")]
  )
  major_parameters <- major_parameters[
    !(duplicates & grepl("phi\\_mat", major_parameters$variable)),
  ]

  mid_cols <- which(
    colnames(major_parameters) %in% c("median", "sd", "mad") |
      grepl("\\%", colnames(major_parameters))
  )
  major_parameters[
    major_parameters$variable == "ppp",
    mid_cols
  ] <- NA_real_

  major_parameters <- modify_major_params(
    major_parameters,
    which(major_parameters$variable %in% c("ppp", "rmsea_mn")),
    group = "Goodness of fit",
    from = from_list[1]
  )
  major_parameters <- modify_major_params(
    major_parameters,
    which(major_parameters$variable == "rms_src"),
    group = "Goodness of fit",
    from = from_list[2]
  )

  idxs <- which(grepl("Load\\_mat", major_parameters$variable))
  major_parameters <- modify_major_params(
    major_parameters, idxs,
    group = "Factor loadings", op = "=~",
    from = factor_labels[as.integer(
      gsub("Load_mat\\[\\d+,|\\]", "", major_parameters[idxs, ]$variable)
    )],
    to = indicator_labels[as.integer(
      gsub("Load_mat\\[|,\\d+\\]", "", major_parameters[idxs, ]$variable)
    )]
  )

  idxs <- which(grepl("res\\_cor", major_parameters$variable))
  major_parameters <- modify_major_params(
    major_parameters, idxs,
    group = "Error correlations", op = "~~",
    from = indicator_labels[data_list$error_mat[, 1]],
    to = indicator_labels[data_list$error_mat[, 2]]
  )

  idxs <- which(grepl("res\\_var", major_parameters$variable))
  major_parameters <- modify_major_params(
    major_parameters, idxs,
    group = "Residual variances", op = "~~",
    from = indicator_labels[as.integer(
      gsub("res_var\\[|\\]", "", major_parameters[idxs, ]$variable)
    )],
    to = indicator_labels[as.integer(
      gsub("res_var\\[|\\]", "", major_parameters[idxs, ]$variable)
    )]
  )

  idxs <- which(grepl("phi\\_mat", major_parameters$variable))
  major_parameters <- modify_major_params(
    major_parameters, idxs,
    group = "Inter-factor correlations", op = "~~",
    from = factor_labels[as.integer(
      gsub("phi_mat\\[\\d+,|\\]", "", major_parameters[idxs, ]$variable)
    )],
    to = factor_labels[as.integer(
      gsub("phi_mat\\[|,\\d+\\]", "", major_parameters[idxs, ]$variable)
    )]
  )
  major_parameters <- major_parameters[
    !(major_parameters$group == "Inter-factor correlations" &
      major_parameters$from == major_parameters$to),
  ]

  idxs <- which(grepl("phi\\_cor", major_parameters$variable))
  major_parameters <- modify_major_params(
    major_parameters, idxs,
    group = "Inter-factor correlations", op = "~~",
    from = factor_labels[data_list$F_corr_mat[, 1]],
    to = factor_labels[data_list$F_corr_mat[, 2]]
  )

  idxs <- which(grepl("r\\_square", major_parameters$variable))
  major_parameters <- modify_major_params(
    major_parameters, idxs,
    group = "R square", op = "~~",
    from = factor_labels[as.integer(
      gsub("r_square\\[|\\]", "", major_parameters[idxs, ]$variable)
    )],
    to = factor_labels[as.integer(
      gsub("r_square\\[|\\]", "", major_parameters[idxs, ]$variable)
    )]
  )

  idxs <- which(grepl("Coef\\_mat", major_parameters$variable))
  major_parameters <- modify_major_params(
    major_parameters, idxs,
    group = "Latent regression coefficients", op = "~",
    from = factor_labels[as.integer(
      gsub("Coef_mat\\[|,\\d+\\]", "", major_parameters[idxs, ]$variable)
    )],
    to = factor_labels[as.integer(
      gsub("Coef_mat\\[\\d+,|\\]", "", major_parameters[idxs, ]$variable)
    )]
  )

  major_parameters$ess_bulk <- round(major_parameters$ess_bulk, 1)
  major_parameters$ess_tail <- round(major_parameters$ess_tail, 1)

  target <- c(
    "Goodness of fit",
    "Dispersion between and within clusters",
    "Latent regression coefficients", "R square",
    "Factor loadings", "Inter-factor correlations",
    "Residual variances", "Error correlations"
  )

  new_order <- unlist(sapply(target, function(x) {
    which(major_parameters$group == x)
  }))
  major_parameters <- major_parameters[new_order, -1]
  new_order <- unlist(sapply(c("PPP", "RMSEA", "RMSE"), function(x) {
    which(major_parameters$from[1:2] == x)
  }))
  major_parameters[1:2, ] <- major_parameters[new_order, ]

  return(major_parameters)
}

#' Plotting param_type validation
#'
#' @param param_type param_type for plotting
#' @returns NULL
#' @keywords internal
validate_param_type <- function(param_type) {
  if (any(
    !param_type %in% c("all", "rm", "lo", "ev", "rc", "fc", "rsq", "co", "re")
  ) ||
    is.null(param_type)) {
    stop(paste0(
      "All param_type options must be in ",
      "c(\"all\", \"rm\", \"lo\", \"ev\", \"rc\", \"fc\", ",
      "\"rsq\", \"co\", \"re\")"
    ))
  }
}

#' Rename columns of posterior data.frame prior by parameter type
#'
#' @param df Posterior data.frame
#' @param labels_1 Labels for first variable
#' @param labels_2 Labels for second variable
#' @param begin_name String to begin columns names with
#' @param operation Operation, one of =~, ~, ~~
#' @param search_replace TRUE/FALSE for type of column naming
#' @param search_term_1 Terms to use in replacement for first variable
#' @param search_term_2 Terms to use in replacement for second variable
#' @returns A renamed posterior data.frame
#' @keywords internal
rename_post_df_columns <- function(
    df,
    labels_1,
    labels_2,
    begin_name,
    operation,
    search_replace,
    search_term_1,
    search_term_2) {
  col_names <- colnames(df)
  len_vars <- length(col_names) - 3
  col_names <- col_names[1:len_vars]
  part_1 <- vector("character")
  part_2 <- vector("character")
  if (search_replace == TRUE) {
    part_1 <- labels_1[as.integer(
      gsub(search_term_1, "", col_names)
    )]
    part_2 <- labels_2[as.integer(
      gsub(search_term_2, "", col_names)
    )]
  } else {
    part_1 <- labels_1[search_term_1]
    part_2 <- labels_2[search_term_2]
  }
  col_names <- paste0(begin_name, " ", part_1, operation, part_2)
  colnames(df)[1:len_vars] <- col_names

  return(df)
}

#' Include minor factor residuals in model implied covariance matrix,
#' helper function
#'
#' @param omega_mat model implied covariance matrix to be updated
#' @param params vector of posterior samples from a single iteration
#' @param data_list Data list object passed to Stan
#' @returns A single model-impled covariance matrix
#' @keywords internal
include_residuals <- function(omega_mat, params, data_list) {
  if (data_list$method >= 90) {
    # there is no residual to include for this method
    return(omega_mat)
  }
  tv <- diag(omega_mat)
  n_re <- data_list$Ni * (data_list$Ni - 1) / 2
  re <- params[paste0("resids[", 1:n_re, "]")]
  rm <- params["rms_src_p[1]"]
  pos <- 0
  for (i in 2:data_list$Ni) {
    for (j in 1:(i - 1)) {
      pos <- pos + 1
      omega_mat[i, j] <- omega_mat[i, j] + re[pos] * rm * sqrt(tv[i] * tv[j])
      omega_mat[j, i] <- omega_mat[i, j]
    }
  }
  return(omega_mat)
}

#' Create model implied covariance matrix from CFA, helper function
#'
#' @param params vector of posterior samples from a single iteration
#' @param data_list Data list object passed to Stan
#' @param include_residuals (LOGICAL)
#' TRUE: Include minor factor residual covariances
#' in model-implied covariance matrix;
#' FALSE: Exclude them. If TRUE, different
#' models fit to the data will hardly be distinguishable.
#' @param all_lo loading indexes
#' @param all_ev error variance indexes
#' @param all_ph factor correlation indexes
#' @returns A single model-impled covariance matrix
#' @keywords internal
create_single_cfa_vcov_row <- function(
    params,
    data_list,
    include_residuals,
    all_lo,
    all_ev,
    all_ph) {
  lo_mat <- matrix(params[all_lo], nrow = data_list$Ni, ncol = data_list$Nf)
  ev <- params[all_ev]

  ph_mat <- diag(data_list$Nf)
  if (data_list$corr_fac == 1) {
    ph_mat <- matrix(params[all_ph], nrow = data_list$Nf, ncol = data_list$Nf)
  }

  lpl_mat <- lo_mat %*% ph_mat %*% t(lo_mat)

  lpe_mat <- matrix(0, nrow = data_list$Ni, ncol = data_list$Nce)
  if (ncol(lpe_mat) > 0) {
    rc <- params[paste0("res_cor[", 1:data_list$Nce, "]")]
    for (i in 1:data_list$Nce) {
      lpe_mat[data_list$error_mat[i, 1], i] <- sqrt(
        abs(rc[i]) * ev[data_list$error_mat[i, 1]]
      )
      lpe_mat[data_list$error_mat[i, 2], i] <- sign(rc[i]) * sqrt(
        abs(rc[i]) * ev[data_list$error_mat[i, 2]]
      )
    }
  }
  lpe_sq_mat <- tcrossprod(lpe_mat)

  d_ast <- ev - diag(lpe_sq_mat)

  omega_mat <- lpl_mat + lpe_sq_mat + diag(d_ast)

  if (include_residuals == TRUE) {
    omega_mat <- include_residuals(omega_mat, params, data_list)
  }

  return(omega_mat)
}

#' Create model implied covariance matrix from SEM, helper function
#'
#' @param params vector of posterior samples from a single iteration
#' @param data_list Data list object passed to Stan
#' @param include_residuals (LOGICAL)
#' TRUE: Include minor factor residual covariances
#' in model-implied covariance matrix; FALSE: Exclude them. If TRUE, different
#' models fit to the data will hardly be distinguishable.
#' @param all_lo loading indexes
#' @param all_ev error variance indexes
#' @param all_ph factor correlation indexes
#' @param all_co latent coefficient indexes
#' @param all_fv factor variance indexes
#' @returns A single model-impled covariance matrix
#' @keywords internal
create_single_sem_vcov_row <- function(
    params,
    data_list,
    include_residuals,
    all_lo,
    all_ev,
    all_ph,
    all_co,
    all_fv) {
  lo_mat <- matrix(params[all_lo], nrow = data_list$Ni, ncol = data_list$Nf)
  co_mat <- matrix(params[all_co], nrow = data_list$Nf, ncol = data_list$Nf)
  ev <- params[all_ev]
  fv <- params[all_fv]

  lombi_mat <- lo_mat %*% solve(diag(data_list$Nf) - co_mat)

  fpe_mat <- matrix(0, nrow = data_list$Nf, ncol = data_list$Nf_corr)
  if (ncol(fpe_mat) > 0) {
    fc <- params[all_ph]
    for (i in 1:data_list$Nf_corr) {
      fpe_mat[data_list$F_corr_mat[i, 1], i] <- sqrt(
        abs(fc[i]) * ev[data_list$F_corr_mat[i, 1]]
      )
      fpe_mat[data_list$F_corr_mat[i, 2], i] <- sign(fc[i]) * sqrt(
        abs(fc[i]) * ev[data_list$F_corr_mat[i, 2]]
      )
    }
  }
  fpe_sq_mat <- tcrossprod(fpe_mat)
  fvr <- fv - diag(fpe_sq_mat)

  lpe_mat <- matrix(0, nrow = data_list$Ni, ncol = data_list$Nce)
  if (ncol(lpe_mat) > 0) {
    rc <- params[paste0("res_cor[", 1:data_list$Nce, "]")]
    for (i in 1:data_list$Nce) {
      lpe_mat[data_list$error_mat[i, 1], i] <- sqrt(
        abs(rc[i]) * ev[data_list$error_mat[i, 1]]
      )
      lpe_mat[data_list$error_mat[i, 2], i] <- sign(rc[i]) * sqrt(
        abs(rc[i]) * ev[data_list$error_mat[i, 2]]
      )
    }
  }
  lpe_sq_mat <- tcrossprod(lpe_mat)

  d_ast <- ev - diag(lpe_sq_mat)

  omega_mat <- lombi_mat %*% (
    fpe_sq_mat + diag(fvr)
  ) %*% t(lombi_mat) + lpe_sq_mat + diag(d_ast)

  if (include_residuals == TRUE) {
    omega_mat <- include_residuals(omega_mat, params, data_list)
  }

  return(omega_mat)
}

#' Create model implied cov matrix or log-likelihood helper function
#'
#' @param mat Matrix of posterior samples
#' @param data_list Data list object passed to Stan
#' @param include_residuals (LOGICAL)
#' TRUE: Include minor factor residual covariances
#' in model-implied covariance matrix; FALSE: Exclude them. If TRUE, different
#' models fit to the data will hardly be distinguishable.
#' @param return_ll (LOGICAL)
#' TRUE: Return matrix of log-likelihood
#' FALSE: Return matrix of covariances
#' @returns Returns a matrix, which one depends on
#' \code{return_ll} argument.
#' @keywords internal
create_mi_vcov_ll <- function(
    mat,
    data_list,
    include_residuals,
    return_ll = FALSE) {
  all_ev <- paste0("res_var[", 1:data_list$Ni, "]")
  all_lo <- paste0("Load_mat[", apply(which(
    data_list$loading_pattern != 2,
    arr.ind = TRUE
  ), 1, paste0, collapse = ","), "]")
  all_ph <- NULL

  returned_mat <- matrix()
  if (data_list$method == 91) {
    sigma_cols <- colnames(mat)
    sigma_cols <- sigma_cols[which(grepl("Sigma\\[", sigma_cols))]
    returned_mat <- mat[, sigma_cols]
    if (isTRUE(return_ll)) {
      mu <- rep(0, data_list$Ni)
      y_dat_t <- t(data_list$Y) - colMeans(data_list$Y)
      returned_mat <- apply(returned_mat, 1, function(m) {
        m_vcov <- matrix(m, nrow = data_list$Ni, ncol = data_list$Ni)
        mb_ldmvn(y_dat_t, mu, m_vcov)
      })
    } else {
      returned_mat <- t(returned_mat)
    }
  } else if (data_list$sem_indicator == 0) {
    if (data_list$corr_fac == 1) {
      all_ph <- paste0("phi_mat[", apply(which(
        diag(data_list$Nf) != 2,
        arr.ind = TRUE
      ), 1, paste0, collapse = ","), "]")
    }

    if (isFALSE(return_ll)) {
      returned_mat <- apply(
        mat, 1, create_single_cfa_vcov_row,
        data_list = data_list, include_residuals = include_residuals,
        all_lo = all_lo, all_ev = all_ev, all_ph = all_ph
      )
    } else if (isTRUE(return_ll)) {
      mu <- rep(0, data_list$Ni)
      y_dat_t <- t(data_list$Y) - colMeans(data_list$Y)
      returned_mat <- apply(mat, 1, function(m) {
        m_vcov <- create_single_cfa_vcov_row(
          m,
          data_list = data_list, include_residuals = include_residuals,
          all_lo = all_lo, all_ev = all_ev, all_ph = all_ph
        )
        mb_ldmvn(y_dat_t, mu, m_vcov)
      })
    }
  } else if (data_list$sem_indicator == 1) {
    # Use _u Coefs and Loads as these are unstandardized
    all_lo <- paste0("Load_mat_u[", apply(which(
      data_list$loading_pattern != 2,
      arr.ind = TRUE
    ), 1, paste0, collapse = ","), "]")
    all_co <- paste0("Coef_mat_u[", apply(which(
      data_list$coef_pattern != 2,
      arr.ind = TRUE
    ), 1, paste0, collapse = ","), "]")
    all_fv <- paste0("phi_var[", 1:data_list$Nf, "]")
    if (data_list$Nf_corr > 0) {
      all_ph <- paste0("phi_cor[", 1:data_list$Nf_corr, "]")
    }

    if (isFALSE(return_ll)) {
      returned_mat <- apply(
        mat, 1, create_single_sem_vcov_row,
        data_list = data_list, include_residuals = include_residuals,
        all_lo = all_lo, all_ev = all_ev, all_ph = all_ph,
        all_co = all_co, all_fv = all_fv
      )
    } else if (isTRUE(return_ll)) {
      mu <- rep(0, data_list$Ni)
      y_dat_t <- t(data_list$Y) - colMeans(data_list$Y)
      returned_mat <- apply(mat, 1, function(m) {
        m_vcov <- create_single_sem_vcov_row(
          m,
          data_list = data_list, include_residuals = include_residuals,
          all_lo = all_lo, all_ev = all_ev, all_ph = all_ph,
          all_co = all_co, all_fv = all_fv
        )
        mb_ldmvn(y_dat_t, mu, m_vcov)
      })
    }
  }

  return(returned_mat)
}
